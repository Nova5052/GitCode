1.del 使用del可以删除变量，会直接将变量从内存中删除，程序后续无法再使用该变量。
2.被 import的模块会在根目录生成 .pyc类型的文件。它是被编译过的二进制文件。加快运行速度。
3.列表就等同于数组，使用[]定义。
4.len(列表)是返回列表长度。列表.Count("abc") 是统计abc在列表中出现的次数。
5.列表.remove("abc") 删除列表中的第一个 abc 
6.列表.sort() 升序或者将降序排列; 列表.reverse() 反转列表，在原列表的基础上直接反转排列。
7.选中一段代码 按Tab键增加缩进;按 Shift+Tab 减少缩进; 按 Ctrl+K 整段注释
8.字典用 {} 定义。使用update可将一个字典B添加到另外一个字典A里面。如果有重复项，会更新掉A字典里的值。

字符串相关
9.定义字符串可以用单引号也可以用双引号(默认)。如果字符串中本身就有双引号，那么字符串就可以用单引号来定义。str='我的外号是"大西瓜"'
10.isspace:判断是否只包含空格或者\r\n\t 之类的空白字符。
11.isdecimal(默认)、isnumeric、isdigit 判断是否为纯数字。只能判断整数不能判断小数。
12.startswith、endwith 判断是否以指定字符(串)开始或者结束
13.index和find都可以查找字符串中指定字符串的索引。若不包含指定字符串，inde会报错，find会返回 -1。
14.replace 替换指定字符串。本身字符串不会变，会生成并返回一个新的字符串。
15.center(居中)、ljust(左对齐)、rjust(右对齐)
16.split() 拆分字符串，不传参数时默认使用 空格分割。join() 将列表字符串拼接。
17.可变类型包括:列表、字典; 不可变类型包括:数字，字符串，元组

函数相关
18.全局变量在函数中不会被改变，若在函数中给他赋值，实际上是创建了一个同名局部变量。即使通过实参传递也不行。若需要修改 使用 global
19.函数实参传递时，传递的是引用。
20.无论传入的参数是可变参数(列表，字典)还是不可变参数(数字，字符串，元组)。在函数中对其进行赋值(一定是=号进行赋值)，都不会改变原有的数据值。
21.接上一条。如果在函数内部使用 列表，字典的 append 之类的内部运算符，则会改变外部数据的值。
22.接20. 对列表进行 +=操作时，实际上类似于执行的 extend操作，所以会改变外部数据的值。对数字，字符串进行 += 运算，则不会改变外部数据的值。
23.函数的默认参数必须放在末尾。具有多个缺省参数时，需要指定给哪个参数传递数据。
24.多值参数:函数处理的参数的个数如果是不确定的，可以使用多值参数。 参数前加*,用来接收元组(*args);参数前加 **,用来接收字典(**kwargs)
25.接上一条 使用 *,**进行参数传入拆包。demo(1,*gl_tuple,**gl_dic) ,不然后续传入的值都会作为元组的数据传入。

面向对象
26.创建对象时，自动调用__init__方法。分配空间，初始化属性的初始值。
27. == 运算符 与 is(身份判断运算符)的区别。==是判断值是否相等，is 判读内存地址是否一样。is更加的深入。判断是否等于 None时，最好用 is
28.定义属性或者方法时在前面加 __ 就成了私有属性。对象内部可以访问私有属性。如果想在外部访问私有方法(属性)，可以使用 _类名__私有方法()或 _类名__私有属性 的方式访问。
29.重写方法后，在新的方法中，可以通过 super().父类方法 来调用父类的方法。
30.子类定义的方法中，不能直接访问父类的私有属性和方法。
31.如果想访问父类的私有属性和方法怎么办？可以在父类中定义公有方法，访问自己的私有属性和方法。子类通过访问该公有方法就能访问父类的私有属性和方法了。
32.多继承的情况下，如果两个父类有同名的方法，子类率先调用 '先继承' 的类的方法。扩展内容:类.__mro__ 可以查看调用顺序。
33.python3中所有的类都继承与 object 类
34.类属性:定义在类中，用来记录与类有关的数据。它与任何实例化的对象都无关系。不能在 __init__ 中定义。直接通过 类名.类属性 来调用。
35.接上一条。 对象可以直接获取类属性的值。(对象.类属性名称)但是如果使用赋值语句去修改类属性的值，实际不会修改，而是在对象中新建一个同名的对象属性。
36.使用 @classmethod 创建类方法。使用 cls.类属性 访问类属性。类方法的主要目的就是为了在类的内部访问类属性的！！！
37.假设类里面的方法不需要访问类属性，也不需要访问实例属性。可以创建静态方法。通过 @staticmethod 来创建
38.总结：类方法：只需要访问类属性; 静态方法：既不要访问类属性又不要访问实例属性; 实例方法:既要访问实例属性，又要访问类属性

设计模式
39.单例设计模式。内存中只有唯一的一个实例。
40.__new__ 内置静态方法。负责分配内存空间并且返回对象的引用。调用完后再调用 __init__ 方法。
class VedioPlayer(object):
    # 记录第一个被创建对象的引用
    instance = None
    def __new__(cls, *args, **kwargs):  # 分配空间
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        return cls.instance

核心思想就是使用类属性记录第一个实例的引用。后续再实例化对象的时候，就返回类属性保存的实例地址。

模块
41. from 模块名 import..方式导入属性或者方法后，不需要指定模块名(别名)就能直接调用。若从不同的模块导入的函数有重名，则后导入的覆盖先导入的。
42.接上一条，若不想覆盖，则可以使用别名的方式重命名
43. from 模块名 import * 导入所有方法
44.解释器找导入的模块时，先从运行目录下寻找，再从系统目录下寻找。
45. 模块名.__file__ 可以查看模块的目录。
46.一个模块如果被导入，则在导入的时候，没有被缩进的可以直接执行的代码都会被执行一遍。
47.编写模块的结束后，通常都需要进行测试。可以使用语句  if __name__ == "__main__" 然后在这个if语句里测试调用开发的方法等。
48.接上一条。如果该模块被导入。 if __name__ == "__main__" 下面的代码不会被导入并执行。因为此时 __name__ 等于 该模块的名称而不是 "__main__"

包
49.包中包含多个模块，并且必须包含 __init__.py 文件
50.如果该包需要被外界引用。需要在此文件中添加以下代码:   from . import 模块名

















